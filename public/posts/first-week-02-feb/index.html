<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>First Week | Raphaël Sterbac Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Subtyping and Parametrised Inductive Types
On Tuesday, which was my first proper day, I focused on the potential issues we could
encounter when adding structural subtyping and Parametrised Inductive types. A typical
and pathological example of the latter is the list datatype $\text{List}(A)$.
If we allow the user to deduce $l : \text{List}(U_{i&#43;1})$ from $l : \text{List}(U_{i})$,
then we would also have both $nil_{i} : \text{List}(U_{i&#43;1})$ and $nil_{i&#43;1} : \text{List}(U_{i&#43;1})$.
However, we wouldn&rsquo;t have $nil_{i}  = nil_{i&#43;1}$, unless we add the equation. This breaks canonicity
for inductive types, and could lead to weird error messages on the user-side such as Could not unify nil and nil.">
    <meta name="generator" content="Hugo 0.154.5">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/first-week-02-feb/">
    

    
    
    <meta property="og:url" content="http://localhost:1313/posts/first-week-02-feb/">
  <meta property="og:site_name" content="Raphaël Sterbac Blog">
  <meta property="og:title" content="First Week">
  <meta property="og:description" content="Subtyping and Parametrised Inductive Types On Tuesday, which was my first proper day, I focused on the potential issues we could encounter when adding structural subtyping and Parametrised Inductive types. A typical and pathological example of the latter is the list datatype $\text{List}(A)$.
If we allow the user to deduce $l : \text{List}(U_{i&#43;1})$ from $l : \text{List}(U_{i})$, then we would also have both $nil_{i} : \text{List}(U_{i&#43;1})$ and $nil_{i&#43;1} : \text{List}(U_{i&#43;1})$. However, we wouldn’t have $nil_{i} = nil_{i&#43;1}$, unless we add the equation. This breaks canonicity for inductive types, and could lead to weird error messages on the user-side such as Could not unify nil and nil.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-05T18:03:24+00:00">
    <meta property="article:modified_time" content="2026-02-05T18:03:24+00:00">

  <meta itemprop="name" content="First Week">
  <meta itemprop="description" content="Subtyping and Parametrised Inductive Types On Tuesday, which was my first proper day, I focused on the potential issues we could encounter when adding structural subtyping and Parametrised Inductive types. A typical and pathological example of the latter is the list datatype $\text{List}(A)$.
If we allow the user to deduce $l : \text{List}(U_{i&#43;1})$ from $l : \text{List}(U_{i})$, then we would also have both $nil_{i} : \text{List}(U_{i&#43;1})$ and $nil_{i&#43;1} : \text{List}(U_{i&#43;1})$. However, we wouldn’t have $nil_{i} = nil_{i&#43;1}$, unless we add the equation. This breaks canonicity for inductive types, and could lead to weird error messages on the user-side such as Could not unify nil and nil.">
  <meta itemprop="datePublished" content="2026-02-05T18:03:24+00:00">
  <meta itemprop="dateModified" content="2026-02-05T18:03:24+00:00">
  <meta itemprop="wordCount" content="663">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="First Week">
  <meta name="twitter:description" content="Subtyping and Parametrised Inductive Types On Tuesday, which was my first proper day, I focused on the potential issues we could encounter when adding structural subtyping and Parametrised Inductive types. A typical and pathological example of the latter is the list datatype $\text{List}(A)$.
If we allow the user to deduce $l : \text{List}(U_{i&#43;1})$ from $l : \text{List}(U_{i})$, then we would also have both $nil_{i} : \text{List}(U_{i&#43;1})$ and $nil_{i&#43;1} : \text{List}(U_{i&#43;1})$. However, we wouldn’t have $nil_{i} = nil_{i&#43;1}$, unless we add the equation. This breaks canonicity for inductive types, and could lead to weird error messages on the user-side such as Could not unify nil and nil.">

	
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.css" integrity="sha384-Wsr4Nh3yrvMf2KCebJchRJoVo1gTU6kcP05uRSh5NV3sj9+a8IomuJoQzf3sMq4T" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/katex.min.js" integrity="sha384-+W9OcrYK2/bD7BmUAk+xeFAyKp0QjyRQUCxeU31dfyTt/FrPsUgaBTLLkVf33qWt" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.28/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>




  </head><body class="ma0 avenir bg-near-white development is-page is-page page-First-Week-02-Feb">
    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        Raphaël Sterbac Blog
      
    </a>
    <div class="flex-l items-center">
      

      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  

  <article class="page-First-Week-02-Feb flex-l mw7 center ph3 flex-wrap justify-between">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">First Week</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2026-02-05T18:03:24Z">February 5, 2026</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-100-l"><h1 id="subtyping-and-parametrised-inductive-types">Subtyping and Parametrised Inductive Types</h1>
<p>On Tuesday, which was my first proper day, I focused on the potential issues we could
encounter when adding structural subtyping and Parametrised Inductive types. A typical
and pathological example of the latter is the list datatype $\text{List}(A)$.</p>
<p>If we allow the user to deduce $l : \text{List}(U_{i+1})$ from $l : \text{List}(U_{i})$,
then we would also have both $nil_{i} : \text{List}(U_{i+1})$ and $nil_{i+1} : \text{List}(U_{i+1})$.
However, we wouldn&rsquo;t have $nil_{i}  = nil_{i+1}$, unless we add the equation. This breaks canonicity
for inductive types, and could lead to weird error messages on the user-side such as <code>Could not unify nil and nil</code>.</p>
<h1 id="elaboration-of-the-universe-hierarchy">Elaboration of the universe hierarchy</h1>
<p>I&rsquo;ve been working on the elaboration of the universe hierarchy, namely translating the user
syntax for universes (close to Russell-style universes) to the core language using the &ldquo;Fuss-Free universe
hierarchy&rdquo; with smallness judgement.</p>
<p>To do this, I first got used to bidirectional elaboration as described in <em>Cosmology of datatypes</em>, and then
tried to write the specification. First, I specified the definitions for type-connective codes, as it is done
for the product type in the blogpost.</p>
<p>For example, the elaboration should translate $\Pi A B :  U_i$ to $\Pi^i A&rsquo; B&rsquo; : U_i$ where $\Pi^i$ is the
code for product types and $A&rsquo;$, $B&rsquo;$ are the elaborated versions of $A$ and $B$.</p>
<p>We can also do that for universes, and I&rsquo;m currently thinking on how to elaborate lifts/cummulativity and
generic datatypes or inductive types.</p>
<p>Also, I am not &ldquo;calling&rdquo; the unification algorithm at the moment, and I&rsquo;m not sure to see where it would be needed.</p>
<h1 id="injectivity-of-decoding-and-lifting">Injectivity of decoding and lifting</h1>
<p>I spent some time thinking about how to prove injectivity of decoding and lifting. First,
I was trying to prove it using a normalisation by evaluation method, such as the one for proving
injectivity of product types. However, it did not seem to be as easy as for products.</p>
<p>Then, I realised that I may have already proved the result in some sense with Thierry last year. Namely,
we proved that Russell and Tarski formulations of universes were equivalent. Translating injectivity of lifts
from Tarski-style to Russell-style amounts to proving that if $\Gamma \vdash a = b : U_j$ and $\Gamma \vdash a,b : U_i$ with $i &lt; j$, then
we can construct a proof of $\Gamma \vdash a = b : U_i$. This can be proven easily by induction
on the derivation, <em>mutatis mutandis</em>.</p>
<p>With the equivalence result, we can then convert the judgement $\Gamma \vdash t_i^j(a) = t_i^j(b) : U_j$ back and forth,
to get directly $\Gamma \vdash a = b : U_i$ in the Tarski theory !</p>
<p>This proof seems quite elegant and intuitive to me if we think as the Russell theory as a kind of model. The hard work is hidden
in the equivalence result. Concretely,
the important (and non trivial) result that embodies the injectivity is the &ldquo;uniqueness up to erasure&rdquo; result.</p>
<p><strong>Uniqueness up to erasure.</strong> If $\Gamma \vdash u_0 : A_0$ and $\Gamma \vdash u_1 : A_1$ in Tarski-style, with $|u_0| = |u_1|$ and
$|A_0| = |A_1|$ (syntaxical equality when removing all the lifts), then : $\Gamma \vdash A_0 = A_1$ and  $\Gamma \vdash u_0 = u_1 : A_0$.</p>
<p>To me this indicates that if we can prove normalisation (probably with a gluing argument), we could prove the injectivity result directly
with a clever proof by (mutual) induction.</p>
<h1 id="strict-universes-for-grothendieck-topoi">Strict universes for Grothendieck topoi</h1>
<p>I also spent some time reading the paper <em>Strict universes for Grothendieck topoi</em>, and tried to get the most out of it.</p>
<p>Something that occurred to me is that there is no mention of injectivity of the decoding <code>El</code>, which would correspond
to a kind of &ldquo;injectivity&rdquo; of the generic family in the model.</p>
<p>Maybe the &ldquo;injectivity&rdquo; comes from the universal property of pullback, as if we substitute $a$ and $b$ in $\pi$ and get the same result, by
uniqueness of the pullback we can deduce $a = b$. I&rsquo;m not sure.</p>
<ul class="pa0">
  
</ul>

      
    </div></article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  Raphaël Sterbac Blog 2026 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
